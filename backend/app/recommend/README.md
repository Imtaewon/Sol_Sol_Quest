# 📚 퀘스트 추천 시스템 문서

## 시스템 개요

Sol Sol Quest의 추천 시스템은 사용자 데이터에 따라 진화하는 지능형 추천 시스템입니다.
- **초기**: Cold Start 추천 (설문조사 기반)
- **데이터 축적 후**: 하이브리드 추천 자동 활성화 (CF + CBF)

## 추천 시스템 작동 방식

### 자동 전환 로직
```python
# system.py 452-462행
is_data_sufficient, data_stats = self._check_data_sufficiency(db)

if is_data_sufficient:  # 조건 충족 시 자동으로 하이브리드 추천 활성화
    quest_ids = self._hybrid_recommendation(db, user_id)
else:  # 조건 미충족 시 Cold Start 추천 사용
    # Cold Start 로직 실행
```

### 하이브리드 활성화 조건
| 조건 | 필요 수치 | 현재 체크 방법 |
|------|----------|--------------|
| 전체 상호작용 | ≥ 10,000개 | `is_click=1 OR is_cleared=1` |
| 활성 사용자 | ≥ 1,000명 | 상호작용 있는 고유 사용자 |
| 활성 퀘스트 | ≥ 30개 | 상호작용 있는 고유 퀘스트 |
| 평균 상호작용 | ≥ 5개/사용자 | total_interactions / active_users |

---

## Cold Start 추천 (현재 주로 사용)

### 작동 원리
```
사용자 정보 + 설문 12문항 → 카테고리 점수 계산 → 퀘스트 매칭 → 다양성 적용 → 3개 추천
```

### 점수 계산 방식
```python
# 1. 연령대 가중치 (+1~2점)
if age <= 22: STUDY +2, ENT +1
elif age <= 26: STUDY +1, SAVING +2, ECON +1

# 2. 학년 가중치 (+1점)
if grade <= 2: LIFE +1, ENT +1
else: STUDY +1, SAVING +1, ECON +1

# 3. 설문 답변 가중치 (+3점 per answer)
각 답변별로 매핑된 카테고리에 +3점
```

### 카테고리별 퀘스트 풀
- **STUDY** (6개): 학습, 자기계발 관련
- **SAVING** (15개): 저축, 금융 습관 형성
- **ECON** (6개): 경제 활동, 소비 관리
- **LIFE** (7개): 일상 생활 개선
- **HEALTH** (2개): 건강 관리
- **ENT** (0개): 현재 LIFE/GROWTH 타입에 없음

### 다양성 보장
1차: 서로 다른 카테고리에서 1개씩 선택
2차: 부족한 경우 점수 순으로 추가

---

## 하이브리드 추천 (자동 활성화)

### 구성 요소

#### 1. 협업 필터링 (Collaborative Filtering, CF) - 60% 가중치

**💡 핵심 아이디어**: "나와 비슷한 취향을 가진 사용자들이 좋아한 퀘스트는 나도 좋아할 가능성이 높다"

**🎯 실생활 비유**: 
넷플릭스에서 "당신과 비슷한 취향의 사용자들이 본 영화"를 추천받는 것과 같은 원리입니다. 예를 들어, A와 B가 둘 다 '저축 관련 퀘스트'를 많이 완료했다면, A가 완료한 다른 퀘스트를 B에게 추천하는 방식입니다.

**📊 작동 과정**:
1. **사용자 간 유사도 계산**: 
   - 모든 사용자의 퀘스트 활동 기록을 비교
   - 코사인 유사도*로 "얼마나 비슷한 취향인지" 수치화 (0~1점)
   - 상위 10명의 가장 비슷한 사용자 선정
   
   *코사인 유사도: 두 사용자가 공통으로 수행한 퀘스트들을 기준으로, 활동 패턴이 얼마나 비슷한지 측정. 1에 가까울수록 매우 유사, 0에 가까울수록 전혀 다름

2. **추천 점수 계산**:
   ```
   퀘스트별 점수 = Σ(유사 사용자의 유사도 × 해당 사용자의 퀘스트 선호도)
   
   퀘스트 선호도 = (클릭 여부 × 0.3) + (완료 여부 × 0.7)
   ```
   - **클릭(관심 표시)**: 30% 가중치 - 사용자가 퀘스트에 관심을 보였음
   - **완료(실제 수행)**: 70% 가중치 - 사용자가 실제로 퀘스트를 끝까지 수행했음

3. **예시 시나리오**:
   ```
   철수와 유사한 사용자 3명:
   - 영희 (유사도 0.8): '1만원 저축 퀘스트' 완료 → 0.8 × 0.7 = 0.56점
   - 민수 (유사도 0.6): '1만원 저축 퀘스트' 클릭만 → 0.6 × 0.3 = 0.18점  
   - 지연 (유사도 0.7): '1만원 저축 퀘스트' 완료 → 0.7 × 0.7 = 0.49점
   
   '1만원 저축 퀘스트' 최종 점수 = 0.56 + 0.18 + 0.49 = 1.23점
   ```

#### 2. 콘텐츠 기반 필터링 (Content-Based Filtering, CBF) - 40% 가중치

**💡 핵심 아이디어**: "내가 과거에 좋아했던 퀘스트와 비슷한 특성을 가진 퀘스트를 추천"

**🎯 실생활 비유**: 
유튜브에서 "요리 영상"을 자주 보면 다른 요리 관련 영상을 추천받는 것과 같습니다. 저축 퀘스트를 많이 완료했다면, 다른 저축 관련 퀘스트나 비슷한 난이도의 퀘스트를 추천받게 됩니다.

**📊 작동 과정**:
1. **사용자 선호 패턴 분석**:
   - 과거에 클릭하거나 완료한 퀘스트들의 특성 파악
   - 선호하는 카테고리, 퀘스트 유형, 검증 방식 등을 수치화
   
   ```
   예: 철수의 과거 활동 분석
   - SAVING 카테고리: 5개 완료 (완료율 80%) → 선호도 높음
   - auto 검증 방식: 4개 완료 (완료율 100%) → 매우 선호
   - GROWTH 타입: 3개 완료 (완료율 60%) → 보통 선호
   ```

2. **퀘스트 특성 벡터 생성**:
   각 퀘스트를 다음과 같은 특성으로 표현:
   - **카테고리**: STUDY, SAVING, ECON, LIFE, HEALTH 중 하나
   - **타입**: LIFE(일상), GROWTH(성장) 중 하나
   - **검증 방식**: auto(자동), manual(수동), upload(업로드) 등
   - **보상 경험치**: 퀘스트 난이도 지표 (높을수록 어려움)
   - **목표 횟수**: 완료까지 필요한 횟수 (많을수록 장기 퀘스트)

3. **유사도 계산 및 추천**:
   ```
   퀘스트 점수 = (카테고리 일치도 × 사용자 카테고리 선호도)
                + (타입 일치도 × 사용자 타입 선호도)
                + (검증방식 일치도 × 사용자 검증방식 선호도)
                + (난이도 적합성 점수)
   ```

4. **예시 시나리오**:
   ```
   철수가 과거에 좋아한 퀘스트 특성:
   - SAVING 카테고리를 매우 선호 (점수: 10점)
   - auto 검증 방식 선호 (점수: 8점)
   - 중간 난이도 선호 (보상 50exp 정도)
   
   새로운 퀘스트 평가:
   '매일 가계부 작성' 퀘스트
   - SAVING 카테고리 ✓ → 10점
   - manual 검증 방식 → 0점
   - 보상 30exp (쉬운 편) → 5점
   최종 CBF 점수: 15점
   
   '자동 저축 설정' 퀘스트  
   - SAVING 카테고리 ✓ → 10점
   - auto 검증 방식 ✓ → 8점
   - 보상 50exp (적정 난이도) ✓ → 10점
   최종 CBF 점수: 28점 (더 적합한 추천!)
   ```

### 최종 점수 결합
```python
hybrid_score = 0.6 * CF_score + 0.4 * CBF_score
```

---

## 데이터베이스 구조

### quest_recommendations 테이블
```sql
id (ULID)                -- 고유 ID
user_id                  -- 사용자 ID
quest_id                 -- 퀘스트 ID
recommendation_date      -- 추천 날짜
is_click (0/1)          -- 클릭 여부
is_cleared (0/1)        -- 완료 여부
```

### 데이터 수집 흐름
1. **추천 시점**: 3개 퀘스트 추천 → DB 저장 (is_click=0, is_cleared=0)
2. **클릭 추적**: 퀘스트 상세 조회 시 → is_click=1 업데이트
3. **완료 추적**: 퀘스트 완료 시 → is_cleared=1 업데이트

---

## API 엔드포인트

### 1. 기본 추천
```
GET /quests
```
응답: 3개의 퀘스트 ID 배열

### 2. 상세 추천
```
GET /quests/detailed
```
응답: 퀘스트 상세 정보 포함

### 3. 사용자 선호도
```
GET /user/preferences
```
응답: 카테고리별 점수 (디버깅용)

---

## 기본 추천 (Fallback)

설문조사 미완료 또는 오류 시:
1. quest_growth_008 (신한 계좌 등록)
2. quest_growth_012 (1만원 저축)
3. quest_daily_017 (쏠쏠한 적금 출석)

---

## 모니터링 및 최적화

### 추천 품질 지표
- **CTR**: is_click=1 비율
- **완료율**: is_cleared=1 비율
- **다양성**: 카테고리 분포

### 성능 최적화
```sql
-- 권장 인덱스
CREATE INDEX idx_user_date ON quest_recommendations(user_id, recommendation_date);
CREATE INDEX idx_interactions ON quest_recommendations(is_click, is_cleared);
```

### 데이터 현황 확인
```python
recommendation_system = QuestRecommendationSystem()
is_sufficient, stats = recommendation_system._check_data_sufficiency(db)
print(stats)  # 하이브리드 활성화 진행률 확인
```

---

**Last Updated**: 2025-08-30
